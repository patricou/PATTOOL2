warning: in the working copy of 'PatTool_Front-End/src/app/shared/slideshow-modal/slideshow-modal.component.ts', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/PatTool_Front-End/src/app/shared/slideshow-modal/slideshow-modal.component.ts b/PatTool_Front-End/src/app/shared/slideshow-modal/slideshow-modal.component.ts[m
[1mindex 5315ec1..7896c13 100644[m
[1m--- a/PatTool_Front-End/src/app/shared/slideshow-modal/slideshow-modal.component.ts[m
[1m+++ b/PatTool_Front-End/src/app/shared/slideshow-modal/slideshow-modal.component.ts[m
[36m@@ -815,7 +815,7 @@[m [mexport class SlideshowModalComponent implements OnInit, AfterViewInit, OnDestroy[m
       centered: true[m
     });[m
     [m
[31m-    // Load EXIF data[m
[32m+[m[32m    // Load EXIF data (will use stored blob, no network request)[m
     this.loadExifData().then(() => {[m
       // Cache the EXIF data for future use[m
       if (this.exifData.length > 0) {[m
[36m@@ -849,6 +849,13 @@[m [mexport class SlideshowModalComponent implements OnInit, AfterViewInit, OnDestroy[m
       return;[m
     }[m
     [m
[32m+[m[32m    // Double-check cache (should not happen since showExifInfo checks first, but safety check)[m
[32m+[m[32m    const cachedExifData = this.exifDataCache.get(currentImageUrl);[m
[32m+[m[32m    if (cachedExifData) {[m
[32m+[m[32m      this.exifData = cachedExifData;[m
[32m+[m[32m      return;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     try {[m
       // Get image dimensions from the img element[m
       const imgEl = this.slideshowImgElRef?.nativeElement;[m
[36m@@ -863,26 +870,28 @@[m [mexport class SlideshowModalComponent implements OnInit, AfterViewInit, OnDestroy[m
         });[m
       }[m
       [m
[31m-      // Get blob from image without using fetch (to avoid CSP violation)[m
[32m+[m[32m      // Get blob from stored blobs (NO network request - we always store blobs when loading images)[m
       let blob: Blob | null = null;[m
[31m-      if (currentImageUrl.startsWith('blob:')) {[m
[31m-        // For blob URLs, get the stored blob (avoids CSP violation)[m
[31m-        const storedBlob = this.slideshowBlobs.get(currentImageUrl);[m
[31m-        if (storedBlob) {[m
[31m-          blob = storedBlob;[m
[31m-        } else {[m
[31m-          // If blob not stored, we'll use the image element directly (no fetch/XHR needed)[m
[31m-          // This avoids CSP violation because we're not making a network request[m
[31m-          blob = null; // Will use image element directly[m
[31m-        }[m
[32m+[m[41m      [m
[32m+[m[32m      // First, try to get stored blob (works for both blob URLs and could work for regular URLs if stored)[m
[32m+[m[32m      const storedBlob = this.slideshowBlobs.get(currentImageUrl);[m
[32m+[m[32m      if (storedBlob) {[m
[32m+[m[32m        blob = storedBlob;[m
[32m+[m[32m      } else if (currentImageUrl.startsWith('blob:')) {[m
[32m+[m[32m        // For blob URLs without stored blob, we cannot read EXIF without violating CSP[m
[32m+[m[32m        // This should not happen if images are loaded correctly[m
[32m+[m[32m        console.warn('Blob URL found but no stored blob available. Cannot read EXIF without CSP violation.');[m
[32m+[m[32m        return;[m
       } else {[m
[31m-        // For regular URLs, we can fetch them (they're allowed by CSP)[m
[32m+[m[32m        // For regular URLs (HTTP/HTTPS), only fetch if absolutely necessary[m
[32m+[m[32m        // But ideally, all images should have their blobs stored[m
[32m+[m[32m        // Only fetch as last resort (should rarely happen)[m
         try {[m
           const response = await fetch(currentImageUrl);[m
           blob = await response.blob();[m
         } catch (error) {[m
           console.error('Error fetching image:', error);[m
[31m-          blob = null; // Fallback to using image element directly[m
[32m+[m[32m          blob = null;[m
         }[m
       }[m
       [m
[36m@@ -915,50 +924,61 @@[m [mexport class SlideshowModalComponent implements OnInit, AfterViewInit, OnDestroy[m
   [m
   private async readExifFromBlob(blob: Blob, imageUrl?: string): Promise<void> {[m
     return new Promise((resolve) => {[m
[31m-      // Create a temporary image element to use with EXIF.js[m
[31m-      const img = new Image();[m
[31m-      const objectUrl = URL.createObjectURL(blob);[m
[32m+[m[32m      // Use FileReader to read blob as data URL to avoid CSP violations[m
[32m+[m[32m      const reader = new FileReader();[m
       [m
[31m-      img.onload = () => {[m
[31m-        try {[m
[31m-          EXIF.getData(img as any, () => {[m
[31m-            try {[m
[31m-              const exifData = EXIF.getAllTags(img as any);[m
[31m-              [m
[31m-              // Process EXIF data into display format[m
[31m-              const processedData: Array<{label: string, value: string}> = [];[m
[31m-              this.processExifDataIntoArray(exifData, processedData);[m
[31m-              [m
[31m-              // Cache the processed data if imageUrl is provided (for preloading)[m
[31m-              if (imageUrl && processedData.length > 0) {[m
[31m-                this.exifDataCache.set(imageUrl, processedData);[m
[31m-              }[m
[31m-              [m
[31m-              // If called from loadExifData (user requested), update the UI[m
[31m-              if (!imageUrl) {[m
[31m-                this.exifData = processedData;[m
[32m+[m[32m      reader.onload = (e: any) => {[m
[32m+[m[32m        const dataUrl = e.target.result;[m
[32m+[m[41m        [m
[32m+[m[32m        // Create a temporary image element to use with EXIF.js[m
[32m+[m[32m        const img = new Image();[m
[32m+[m[41m        [m
[32m+[m[32m        img.onload = () => {[m
[32m+[m[32m          try {[m
[32m+[m[32m            EXIF.getData(img as any, () => {[m
[32m+[m[32m              try {[m
[32m+[m[32m                const exifData = EXIF.getAllTags(img as any);[m
[32m+[m[41m                [m
[32m+[m[32m                // Process EXIF data into display format[m
[32m+[m[32m                const processedData: Array<{label: string, value: string}> = [];[m
[32m+[m[32m                this.processExifDataIntoArray(exifData, processedData);[m
[32m+[m[41m                [m
[32m+[m[32m                // Cache the processed data if imageUrl is provided (for preloading)[m
[32m+[m[32m                if (imageUrl && processedData.length > 0) {[m
[32m+[m[32m                  this.exifDataCache.set(imageUrl, processedData);[m
[32m+[m[32m                }[m
[32m+[m[41m                [m
[32m+[m[32m                // If called from loadExifData (user requested), update the UI[m
[32m+[m[32m                if (!imageUrl) {[m
[32m+[m[32m                  this.exifData = processedData;[m
[32m+[m[32m                }[m
[32m+[m[32m              } catch (error) {[m
[32m+[m[32m                console.error('Error processing EXIF data:', error);[m
               }[m
[31m-            } catch (error) {[m
[31m-              console.error('Error processing EXIF data:', error);[m
[31m-            }[m
[31m-            URL.revokeObjectURL(objectUrl);[m
[32m+[m[32m              resolve();[m
[32m+[m[32m            });[m
[32m+[m[32m          } catch (error) {[m
[32m+[m[32m            console.error('Error reading EXIF data:', error);[m
             resolve();[m
[31m-          });[m
[31m-        } catch (error) {[m
[31m-          console.error('Error reading EXIF data:', error);[m
[31m-          URL.revokeObjectURL(objectUrl);[m
[32m+[m[32m          }[m
[32m+[m[32m        };[m
[32m+[m[41m        [m
[32m+[m[32m        img.onerror = (error) => {[m
[32m+[m[32m          console.error('Error loading image from data URL:', error);[m
           resolve();[m
[31m-        }[m
[32m+[m[32m        };[m
[32m+[m[41m        [m
[32m+[m[32m        // Set src after setting up event handlers[m
[32m+[m[32m        img.src = dataUrl;[m
       };[m
       [m
[31m-      img.onerror = (error) => {[m
[31m-        console.error('Error loading image from blob:', error);[m
[31m-        URL.revokeObjectURL(objectUrl);[m
[32m+[m[32m      reader.onerror = (error) => {[m
[32m+[m[32m        console.error('Error reading blob:', error);[m
         resolve();[m
       };[m
       [m
[31m-      // Set src after setting up event handlers[m
[31m-      img.src = objectUrl;[m
[32m+[m[32m      // Read blob as data URL[m
[32m+[m[32m      reader.readAsDataURL(blob);[m
     });[m
   }[m
   [m
